<?xml version="1.0"?>

<ruleset name="newrules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="../etc/ruleset_xml_schema.xml">
  <description>
These are new rules for the next release
  </description>


    <rule name="MissingSerialVersionUID"
          message="Classes implementing Serializable should set a serialVersionUID"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
          Classes that are serializable should provide a serialVersionUID field.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//TypeDeclaration[
//UnmodifiedClassDeclaration/NameList[Name/@Image="Serializable" or Name/@Image="java.io.Serializable"]
and not(
//ClassBodyDeclaration/FieldDeclaration[VariableDeclarator/VariableDeclaratorId/@Image='serialVersionUID'] )
]
]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo implements java.io.Serializable {
    String name;
    // Define serialization id to avoid serialization related bugs
    public static final long serialVersionUID = 4328743;
}

]]>
          </example>
    </rule>

    <rule name="UnnecessaryFinalModifier"
          message="Unnecessary final modifier in final class"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  When a class has the final modifier, all the methods are marked finally.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//*[(name()='ClassDeclaration' or name()='NestedClassDeclaration')
    and @Final='true'] 
/*/*/*/MethodDeclaration[@Final='true']
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public final class Foo {

    // This final modifier is not necessary, since the class is final
    // and thus, all methods are final
	private final void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="AbstractClassDoesNotContainAbstractMethod"
          message="Class is defined abstract but it hasn't any abstract methods"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Abstract classes should have abstract methods, that are to be completed by subclasses.
  If the class is intended to not be instantiated, it should be done by providing private/protected constructors.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
    //ClassDeclaration[
        @Abstract='true'
        and count(//MethodDeclaration[@Abstract='true'])=0
        ]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public abstract class Foo {

    // This constructor prevents the class from being instantiated and makes 
    // unnecessary the usage of the abstract modifier for the class
    protected Foo() {}
    
	void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="MissingStaticMethodInNonInstantiatableClass"
          message="Class cannot be instantiated and does not provide any static method"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  A class that has private constructors and does not have any static method cannot be used.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
    //ClassDeclaration[
        ( count(.//ConstructorDeclaration)>0 and count(.//ConstructorDeclaration) = count(.//ConstructorDeclaration[@Private='true']) )
        and 
        count(.//MethodDeclaration[@Static='true'])=0
        ]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
/* This class is unusable, since it cannot be 
 instantiated (private constructor),
 and no static method can be called. 
 */
public class Foo {

    private Foo() {}
    
	void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="AvoidCallingFinalize"
          message="avoid calling finalize() explicitly"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  finalize() is called by the garbage collector on an object when garbage collection determines 
  that there are no more references to the object.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='finalize'
	or ends-with(@Image,'.finalize')
	]
or @Image='finalize'
]
    
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[

	void foo() {
	    Bar b = new Bar();
	    b.finalize();
	}

]]>
      </example>
    </rule>


    <rule name="AvoidSynchronizedAtMethodLevel"
          message="a method is marked synchronized, try using block level"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  It is preferrable to use synchronized in block level rather than in method level.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration[@Synchronized='true']
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[

    // Try to avoid this
	synchronized void foo() {
	}
	
	// Prefer this:
	void bar() {
	    synchronized(mutex) {
	    }
	}

]]>
      </example>
    </rule>

    <rule name="MissingBreakInSwitch"
          message="A switch statement does not contain a break"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  A switch statement without a break inside can be totally valid, however, it is probably a bug.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//SwitchStatement[count(.//BreakStatement)=0]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>
      <example>
<![CDATA[
switch(status) {
	case CANCELLED:
		doCancelled();
		// uncomment the next line if doNew() and doRemoved() should not be executed when status is cancelled
		// break;
	case NEW:
		doNew();
	case REMOVED:
		doRemoved();
	}
]]>
      </example>
    </rule>
    
    
    <rule name="UseNotifyAllInsteadOfNotify"
          message="avoid calling notify() prefer instead notifyAll()"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
      one is choosen. In this case, the choice is arbitrary and occurs at the discretion of the implementation
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='notify'
	or ends-with(@Image,'.notify')
	]
or @Image='notify'
or (  ./AllocationExpression 
    and ../PrimarySuffix[@Image='notify'] )
]   
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
	x.notify();
	// If many threads are monitoring x, only one (and you won't know which) will be notified.
	// use instead:
	x.notifyAll();
]]>
      </example>
    </rule>


    <rule name="CallSuperInConstructor"
          message="It is a good practice to call super() in a constructor"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      It is a good practice to call super() in a constructor. If super() is not called
      but another consuctor (overloaded constructor) of the class is called, this rule
      will not report it.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ConstructorDeclaration[
count(.//ExplicitConstructorInvocation)=0
]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo extends Bar{
	
	public Foo() {
		// call the constructor of Bar
		super();
	}
	
	public Foo(int code) {
		// do something with code
		this();
		// no problem with this
	}
}
]]>
      </example>
    </rule>
    
     <rule name="AvoidInstanceofChecksInCatchClause"
           message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
           class="net.sourceforge.pmd.rules.XPathRule">
     <description>
   Each caught exception type should be handled in its own catch clause.
       </description>
       <properties>
           <property name="xpath">
               <value>
     <![CDATA[
 //TryStatement/FormalParameter
  /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
   /Name[
    @Image = ./ancestor::Block/preceding-sibling::FormalParameter
     /VariableDeclaratorId/@Image
   ]
     ]]>
               </value>
           </property>
       </properties>
         <priority>3</priority>
       <example>
 <![CDATA[
     // Avoid this
       try {
             ...something...
       }
       catch (Exception ee) {
             if (ee instanceof IOException) {
                 cleanup();
             }
       }

       // Prefer this:
       try {
           ...something...
       }
       catch (IOException ee) {
             cleanup();
       }
 ]]>
       </example>
     </rule>


</ruleset>

