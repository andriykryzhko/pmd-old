<?xml version="1.0"?>

<ruleset name="newrules">
  <description>
These are new rules for the next release
  </description>

    <rule name="ConstructorCallsOverridableMethodRule"
          message="Avoid calls to overridable methods during construction"
          class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethodRule">
      <description>
      Calling overridable methods during construction poses a risk of invoking methods on an
          incompletely constructed object.  This situation can be difficult to discern.
      It may leave the sub-class unable to construct its superclass or forced to
          replicate the construction process completely within itself, losing the ability to call
      super().  If the default constructor contains a call to an overridable method,
          the subclass may be completely uninstantiable.
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name;
      }
    }
  ]]>
      </example>
    </rule>

        <rule name="AtLeastOneConstructor"
          message="Each class should declare at least one constructor"
          class="net.sourceforge.pmd.rules.AtLeastOneConstructorRule">
      <description>
      Each class should declare at least one constructor.  Note that this rule is the
          opposite of UnnecessaryConstructorRule, so running them at the same time will
          result on a rule violation on every class.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  public class Foo {
   // no constructor!  not good!
  }
  ]]>
      </example>
    </rule>

    <rule name="JUnitAssertionsShouldIncludeMessageRule"
          message="JUnit assertions should include a message"
          class="net.sourceforge.pmd.rules.JUnitAssertionsShouldIncludeMessageRule">
      <description>
      JUnit assertions should include a message - i.e., use the three argument version of
          assertEquals(), not the two argument version.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  public class Foo extends TestCase {
    public void testSomething() {
        assertEquals("foo", "bar");
        // not good!  use the form:
        // assertEquals("Foo does not equals bar", "foo", "bar");
        // instead
    }
  }
  ]]>
      </example>
    </rule>


    <rule name="SymbolTableTestRule"
          message="test"
          class="net.sourceforge.pmd.rules.SymbolTableTestRule">
      <description>
      asdsad
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  // asdadas
  ]]>
      </example>
    </rule>

    <rule name="DoubleCheckedLockingRule"
          message="Double checked locking is not thread safe in Java."
          class="net.sourceforge.pmd.rules.DoubleCheckedLockingRule">
      <description>
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[
  public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }
  ]]>
      </example>
    </rule>
  </ruleset>


