<?xml version="1.0"?>

<ruleset name="newrules">
  <description>
These are new rules for the next release
  </description>

    <rule name="ConstructorCallsOverridableMethodRule"
          message="Avoid calls to overridable methods during construction"
          class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethodRule">
      <description>
      Calling overridable methods during construction poses a risk of invoking methods on an
          incompletely constructed object.  This situation can be difficult to discern.
      It may leave the sub-class unable to construct its superclass or forced to
          replicate the construction process completely within itself, losing the ability to call
      super().  If the default constructor contains a call to an overridable method,
          the subclass may be completely uninstantiable.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name;
      }
    }
  ]]>
      </example>
    </rule>

        <rule name="AtLeastOneConstructor"
          message="Each class should declare at least one constructor"
          class="net.sourceforge.pmd.rules.AtLeastOneConstructorRule">
      <description>
      Each class should declare at least one constructor.  Note that this rule is the
          opposite of UnnecessaryConstructorRule, so running them at the same time will
          result on a rule violation on every class.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  public class Foo {
   // no constructor!  not good!
  }
  ]]>
      </example>
    </rule>

    <rule name="JUnitAssertionsShouldIncludeMessageRule"
          message="JUnit assertions should include a message"
          class="net.sourceforge.pmd.rules.junit.JUnitAssertionsShouldIncludeMessageRule">
      <description>
      JUnit assertions should include a message - i.e., use the three argument version of
          assertEquals(), not the two argument version.
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  public class Foo extends TestCase {
    public void testSomething() {
        assertEquals("foo", "bar");
        // not good!  use the form:
        // assertEquals("Foo does not equals bar", "foo", "bar");
        // instead
    }
  }
  ]]>
      </example>
    </rule>


    <rule name="SymbolTableTestRule"
          message="test"
          class="net.sourceforge.pmd.rules.SymbolTableTestRule">
      <description>
      asdsad
      </description>
        <priority>3</priority>

      <example>
  <![CDATA[
  // asdadas
  ]]>
      </example>
    </rule>

    <rule name="DoubleCheckedLockingRule"
          message="Double checked locking is not thread safe in Java."
          class="net.sourceforge.pmd.rules.DoubleCheckedLockingRule">
      <description>
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
  public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }
  ]]>
      </example>
    </rule>


    <rule name="CouplingBetweenObjectsRule"
        message="High amount of different objects as memebers donotes a high coupling"
        class="net.sourceforge.pmd.rules.CouplingBetweenObjectsRule">
    <description>
        Rule counts unique attributes, local variables and return types within an object. An amount
        higher than specified threshold can indicate a high degree of couping with in an object
    </description>
    <priority>3</priority>
    <properties>
      <property name="threshold" value="20"/>
    </properties>
    <example>
    <![CDATA[
      import com.Blah;
      import org.Bar;
      import org.Bardo;
      //
      public class Foo {
        private Blah var1;
        private Bar var2;
        //followed by many imports of unique objects

        void ObjectC doWork() {
           Bardo var55;
           ObjectA var44;
           ObjectZ var93;
           return something;
        }

        }
        ]]>
    </example>
  </rule>

  <rule name="ExcessiveImportsRule"
     message="A high number of imports can indicate a high degree of coupling within an object."
     class="net.sourceforge.pmd.rules.ExcessiveImportsRule">
     <description>
      A high number of imports can indicate a high degree of coupling within
      an object. Rule counts the number of unique imports and reports a violation
      if the count is above the user defined threshold.
  </description>
  <priority>3</priority>
  <properties>
      <property name="minimum" value="30"/>
  </properties>
  <example>
      <![CDATA[
      import blah.blah.Bardo;
      import blah.blah.Hardo;
      import blah.blah.Bar;
      import blah.net.ObjectA;
      //imports over some threshold
      public class Foo {
        public void doWork() {}
      }
      ]]>
  </example>

   </rule>

    <rule name="ExcessivePublicCountRule"
    message="A high number of public methods and attributes in an object can indicate the class may need to be broken up for exhaustive testing may prove difficult."
    class="net.sourceforge.pmd.rules.ExcessivePublicCountRule">
    <description>
    A large amount of public methods and attributes declared in an object can indicate the class may need
    to be broken up as increased effort will be required to thoroughly test such a class.
    </description>
    <priority>3</priority>
    <properties>
    <property name="minimum" value="45"/>
    </properties>
    <example>
    <![CDATA[

    public class Foo {
    public String value;
    public Bar something;
    public Variable var;
    //more public attributes
    public void doWork() {}
    public void doMoreWork() {}
    public void doWorkAgain() {}
    public void doWorking() {}
    public void doWorkIt() {}
    public void doWorkingAgain() {}
    public void doWorkAgainAgain() {}
    public void doWorked() {}

    }
    ]]>
    </example>
    </rule>

    <rule name="AccessorClassGenerationRule"
          message="Avoid instantiation through private constructors from outside of the constructor's class."
          class="net.sourceforge.pmd.rules.AccessorClassGenerationRule">
      <description>
      Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
      A factory method, or non-privitization of the constructor can eliminate this situation.
      The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
      scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
      one with package scope, though not visible to the naked eye.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//Causes generation of accessor
    }
    public class InnerClass {
      private InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//OK, due to public constructor
    }
    public class InnerClass {
      public InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = InnerClass.getInnerClass();//OK
    }
    public static class InnerClass {
      private InnerClass(){
      }
      private static InnerClass getInnerClass(){
        return new InnerClass();
      }
    }
  }

  public class OuterClass {
    private OuterClass(){
    }
    public class InnerClass {
      void method(){
        OuterClass oc = new OuterClass();//Causes generation of accessor
      }
    }
  }
  ]]>
      </example>
    </rule>

  </ruleset>


