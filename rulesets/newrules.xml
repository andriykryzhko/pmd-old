<?xml version="1.0"?>

<ruleset name="newrules" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="../etc/ruleset_xml_schema.xml">
  <description>
These are new rules for the next release
  </description>


    <rule name="MissingSerialVersionUID"
          message="Classes implementing Serializable should set a serialVersionUID"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
          Classes that are serializable should provide a serialVersionUID field.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//TypeDeclaration[
//ClassOrInterfaceDeclaration/ImplementsList[ClassOrInterfaceType/@Image=("Serializable" or "java.io.Serializable")]
and not(
//ClassOrInterfaceBodyDeclaration/FieldDeclaration[VariableDeclarator/VariableDeclaratorId/@Image='serialVersionUID'] )
]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo implements java.io.Serializable {
    String name;
    // Define serialization id to avoid serialization related bugs
    public static final long serialVersionUID = 4328743;
}

]]>
          </example>
    </rule>

    <rule name="UnnecessaryFinalModifier"
          message="Unnecessary final modifier in final class"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  When a class has the final modifier, all the methods are marked finally.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[@Final='true' and @Interface='false']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Final='true']
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public final class Foo {

    // This final modifier is not necessary, since the class is final
    // and thus, all methods are final
	private final void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="AbstractClassDoesNotContainAbstractMethod"
          message="This class is defined abstract but has no abstract methods"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Abstract classes should have abstract methods, that are to be completed by subclasses.
  If the class is intended to not be instantiated, it should be done by providing private/protected constructors.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
    //ClassOrInterfaceDeclaration
      [@Abstract='true']
      [@Interface='false']
      [count(//MethodDeclaration[@Abstract='true'])=0]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public abstract class Foo {

    // This constructor prevents the class from being instantiated and makes 
    // unnecessary the usage of the abstract modifier for the class
    protected Foo() {}
    
	void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="MissingStaticMethodInNonInstantiatableClass"
          message="Class cannot be instantiated and does not provide any static methods"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  A class that has private constructors and does not have any static method cannot be used.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ClassOrInterfaceDeclaration[
( count(.//ConstructorDeclaration)>0
  and count(.//ConstructorDeclaration) = count(.//ConstructorDeclaration[@Private='true']) )
and
count(.//MethodDeclaration[@Static='true'])=0
]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
/* This class is unusable, since it cannot be 
 instantiated (private constructor),
 and no static method can be called. 
 */
public class Foo {

    private Foo() {}
    
	void foo() {
	}
	
}

]]>
      </example>
    </rule>


    <rule name="AvoidCallingFinalize"
          message="Avoid calling finalize() explicitly"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  finalize() is called by the garbage collector on an object when garbage collection determines 
  that there are no more references to the object.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='finalize'
	or ends-with(@Image,'.finalize')
	]
or @Image='finalize'
]
    
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[

	void foo() {
	    Bar b = new Bar();
	    b.finalize();
	}

]]>
      </example>
    </rule>


    <rule name="AvoidSynchronizedAtMethodLevel"
          message="Use block level rather than method level synchronization"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Method level synchronization can backfire when new code is added to the method.  Block-level
  synchronization helps to ensure that only the code that needs synchronization gets it.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//MethodDeclaration[@Synchronized='true']
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[

    // Try to avoid this
	synchronized void foo() {
	}
	
	// Prefer this:
	void bar() {
	    synchronized(mutex) {
	    }
	}

]]>
      </example>
    </rule>

    <rule name="MissingBreakInSwitch"
          message="A switch statement does not contain a break"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  A switch statement without an enclosed break statement may be a bug.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//SwitchStatement[count(.//BreakStatement)=0]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>
      <example>
<![CDATA[
switch(status) {
	case CANCELLED:
		doCancelled();
		// uncomment the next line if doNew() and doRemoved() should not be executed when status is cancelled
		// break;
	case NEW:
		doNew();
	case REMOVED:
		doRemoved();
	}
]]>
      </example>
    </rule>
    
    
    <rule name="UseNotifyAllInsteadOfNotify"
          message="Call Thread.notifyAll() rather than Thread.notify()"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
      one is chosen.  The thread chosen is arbitrary; thus it's usually safer to call notifyAll() instead.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='notify'
	or ends-with(@Image,'.notify')
	]
or @Image='notify'
or (  ./AllocationExpression 
    and ../PrimarySuffix[@Image='notify'] )
]   
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
	x.notify();
	// If many threads are monitoring x, only one (and you won't know which) will be notified.
	// use instead:
	x.notifyAll();
]]>
      </example>
    </rule>


    <rule name="CallSuperInConstructor"
          message="It is a good practice to call super() in a constructor"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      It is a good practice to call super() in a constructor. If super() is not called
      but another constructor, such as an overloaded constructor, of the class is called, this rule
      will not report it.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//ConstructorDeclaration[
count(.//ExplicitConstructorInvocation)=0
]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo extends Bar{
	
	public Foo() {
		// call the constructor of Bar
		super();
	}
	
	public Foo(int code) {
		// do something with code
		this();
		// no problem with this
	}
}
]]>
      </example>
    </rule>
    
     <rule name="AvoidInstanceofChecksInCatchClause"
           message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
           class="net.sourceforge.pmd.rules.XPathRule">
     <description>
   Each caught exception type should be handled in its own catch clause.
       </description>
       <properties>
           <property name="xpath">
               <value>
     <![CDATA[
 //TryStatement/FormalParameter
  /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
   /Name[
    @Image = ./ancestor::Block/preceding-sibling::FormalParameter
     /VariableDeclaratorId/@Image
   ]
     ]]>
               </value>
           </property>
       </properties>
         <priority>3</priority>
       <example>
 <![CDATA[
     // Avoid this
       try {
             ...something...
       }
       catch (Exception ee) {
             if (ee instanceof IOException) {
                 cleanup();
             }
       }

       // Prefer this:
       try {
           ...something...
       }
       catch (IOException ee) {
             cleanup();
       }
 ]]>
       </example>
     </rule>


    <rule name="AvoidFieldNamesMatchingTypeName"
          message="It is somewhat confusing to have a field name matching the declaring class name"
          class="net.sourceforge.pmd.rules.AvoidFieldNamesMatchingTypeName">
      <description>
      It is somewhat confusing to have a field name matching the declaring class name.
      This proabably means that type and or field names could be more precise.
      </description>
      <properties></properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo extends Bar {
	// There's probably a better name for foo
	int foo;	
}
]]>
      </example>
    </rule>
    

    <rule name="AvoidFieldNameMatchingMethodName"
          message="It is somewhat confusing to have a field name with the same name as a method"
          class="net.sourceforge.pmd.rules.AvoidFieldNameMatchingMethodName">
      <description>
      It is somewhat confusing to have a field name with the same name as a method.
      While this is totally legal, having information (field) and actions (method) is 
      not clear naming.
      </description>
      <properties></properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo {	
	Object bar;	
	// bar is data or an action or both?
	void bar() {
	}
}
]]>
      </example>
    </rule>
    

    <rule name="AvoidNonConstructorMethodsWithClassName"
          message="Method {0} is not a constructor but it can be confused with one"
          class="net.sourceforge.pmd.rules.AvoidNonConstructorMethodsWithClassName">
      <description>
      It is very easy to confuse methods with classname with constructors. It is preferrable 
      to name these non-constructor methods in a different way.
      </description>
      <properties></properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo {	
	public void Foo() {
		// not really a constructor...
	}
}
]]>
      </example>
    </rule>


    <rule name="AbstractClassWithoutAbstractMethod"
          message="This abstract class does not have any abstract methods"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      The abstract class does not contain any abstract methods. An abstract class suggests
      an incomplete implementation, which is to be completed by subclasses implementing the
      abstract methods. If the class is intended to be used as a base class only (not to be instantiated 
      direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <properties>
          <property name="xpath">
              <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and
  count( .//MethodDeclaration[@Abstract='true'] )=0 ]
              ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public abstract class Foo {
	void int method1() { ... }
	void int method2() { ... }
	// consider using abstract methods or removing
	// the abstract modifier and adding protected constructors
}
]]>
      </example>
    </rule>

    <rule name="TestClassWithoutTestCases"
          message="This class name ends with 'Test' but contains no test cases"
          class="net.sourceforge.pmd.rules.TestClassWithoutTestCases">
      <description>
      Test classes end with the suffix Test. Having a non-test class with that name is
      not a good practice, since most people will assume it is a test case. Test 
      classes have test methods named testXXX. 
      </description>
      <properties></properties>
        <priority>3</priority>

      <example>
<![CDATA[
//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest {	
   
   public static void main(String[] args) {
   ...
   }

   // code
}
]]>
      </example>
    </rule>


 <rule name="TooManyFields"
       message="Too many fields"
       class="net.sourceforge.pmd.rules.design.TooManyFields">
   <description>
    Classes that have too many fields could be redesigned to have less fields 
    and some nested object grouping some of the information collected on the 
    many fields.
   </description>
     <priority>3</priority>
   <properties>
    <property name="maximum" value="10"/>
   </properties>
   <example>
<![CDATA[
public Class Person {
    String street;
    int number;
    int floor;
    String postal;
    String street;
    long phone;
    String city;
    String state;
    String Country;
    // fields above should be in a class for Address or something similar
    // that information does not really belong to a person, but to a place
    // fields below are really from person
    String firstname;
    String lastname;
    Date born;
    Person father;
    Person mother;
}
]]>
   </example>

 </rule>
        
</ruleset>

