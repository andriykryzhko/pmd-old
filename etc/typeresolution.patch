### Eclipse Workspace Patch 1.0
#P pmd
Index: src/net/sourceforge/pmd/util/CollectionUtil.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/util/CollectionUtil.java,v
retrieving revision 1.3
diff -u -r1.3 CollectionUtil.java
--- src/net/sourceforge/pmd/util/CollectionUtil.java	18 Oct 2006 13:26:10 -0000	1.3
+++ src/net/sourceforge/pmd/util/CollectionUtil.java	25 Oct 2006 01:45:01 -0000
@@ -64,7 +64,23 @@
 		return includeInterfaces && collectionInterfacesByNames.contains(typeName);
 	}
 	
-	
+    /**
+     * Return whether we can identify the typeName as a java.util collection class
+     * or interface as specified.
+     * 
+     * @param clazzType Class
+     * @param includeInterfaces boolean
+     * @return boolean
+     */
+    public static boolean isCollectionType(Class clazzType, boolean includeInterfaces) {
+
+        if (collectionClassesByNames.contains(clazzType)) {
+            return true;
+        }
+
+        return includeInterfaces && collectionInterfacesByNames.contains(clazzType);
+    }
+
     /**
      * Returns the items as a populated set.
      * 
@@ -145,7 +161,7 @@
 		}
 		return true;
 	}
-	
+
 	/**
 	 * A comprehensive isEqual method that handles nulls and arrays safely.
 	 * 
Index: src/net/sourceforge/pmd/rules/design/LooseCoupling.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/rules/design/LooseCoupling.java,v
retrieving revision 1.10
diff -u -r1.10 LooseCoupling.java
--- src/net/sourceforge/pmd/rules/design/LooseCoupling.java	18 Oct 2006 13:26:10 -0000	1.10
+++ src/net/sourceforge/pmd/rules/design/LooseCoupling.java	25 Oct 2006 01:45:01 -0000
@@ -13,13 +13,16 @@
 
 public class LooseCoupling extends AbstractRule {
 
-	// TODO - these should be brought in via external properties
-//    private static final Set implClassNames = CollectionUtil.asSet( new Object[] {
-//    	"ArrayList", "HashSet", "HashMap", "LinkedHashMap", "LinkedHashSet", "TreeSet", "TreeMap", "Vector",
-//    	"java.util.ArrayList", "java.util.HashSet", "java.util.HashMap",
-//    	"java.util.LinkedHashMap", "java.util.LinkedHashSet", "java.util.TreeSet",
-//    	"java.util.TreeMap", "java.util.Vector" 
-//    	});
+    // TODO - these should be brought in via external properties
+    // private static final Set implClassNames = CollectionUtil.asSet( new
+    // Object[] {
+    // "ArrayList", "HashSet", "HashMap", "LinkedHashMap", "LinkedHashSet",
+    // "TreeSet", "TreeMap", "Vector",
+    // "java.util.ArrayList", "java.util.HashSet", "java.util.HashMap",
+    // "java.util.LinkedHashMap", "java.util.LinkedHashSet",
+    // "java.util.TreeSet",
+    // "java.util.TreeMap", "java.util.Vector"
+    // });
 
     public LooseCoupling() {
         super();
@@ -28,7 +31,12 @@
     public Object visit(ASTClassOrInterfaceType node, Object data) {
         Node parent = node.jjtGetParent().jjtGetParent().jjtGetParent();
         String typeName = node.getImage();
-        if (CollectionUtil.isCollectionType(typeName, false) && (parent instanceof ASTFieldDeclaration || parent instanceof ASTFormalParameter || parent instanceof ASTResultType)) {
+        Class clazzType = node.getType();
+        boolean isType = clazzType == null ? CollectionUtil.isCollectionType(typeName, false) : CollectionUtil
+                .isCollectionType(clazzType, false);
+        System.err.println(clazzType + " " + typeName);
+        if (isType
+                && (parent instanceof ASTFieldDeclaration || parent instanceof ASTFormalParameter || parent instanceof ASTResultType)) {
             addViolation(data, node, typeName);
         }
         return data;
Index: src/net/sourceforge/pmd/PMD.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/PMD.java,v
retrieving revision 1.148
diff -u -r1.148 PMD.java
--- src/net/sourceforge/pmd/PMD.java	16 Oct 2006 19:10:42 -0000	1.148
+++ src/net/sourceforge/pmd/PMD.java	25 Oct 2006 01:45:01 -0000
@@ -78,9 +78,13 @@
             sourceTypeHandler.getSymbolFacade().start(rootNode);
 
             Language language = SourceTypeToRuleLanguageMapper.getMappedLanguage(sourceType);
-
-            if (ruleSets.usesDFA(language)) {
+/*            if (ruleSets.usesDFA(language)) {
                 sourceTypeHandler.getDataFlowFacade().start(rootNode);
+            }*/
+
+            if (true) {
+//          if (ruleSets.usesTypeRes(language)) {
+                sourceTypeHandler.getTypeResolutionFacade().start(rootNode);
             }
 
             List acus = new ArrayList();
@@ -209,6 +213,8 @@
     }
 
     public static void main(String[] args) {
+        
+        long start = System.currentTimeMillis();
         CommandLineOptions opts = new CommandLineOptions(args);
 
         SourceFileSelector fileSelector = new SourceFileSelector();
@@ -275,6 +281,11 @@
                 e.printStackTrace();
             }
         }
+        long end = System.currentTimeMillis();
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
     }
 
     /**
Index: src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java,v
retrieving revision 1.5
diff -u -r1.5 ASTClassOrInterfaceType.java
--- src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java	10 Feb 2006 14:26:28 -0000	1.5
+++ src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java	25 Oct 2006 01:45:01 -0000
@@ -1,22 +1,31 @@
-/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceType.java */
-
-package net.sourceforge.pmd.ast;
-
-public class ASTClassOrInterfaceType extends SimpleJavaNode {
-    public ASTClassOrInterfaceType(int id) {
-        super(id);
-    }
-
-    public ASTClassOrInterfaceType(JavaParser p, int id) {
-        super(p, id);
-    }
-
-
-    /**
-     * Accept the visitor. *
-     */
-    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
-        return visitor.visit(this, data);
-    }
-
-}
+/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceType.java */
+
+package net.sourceforge.pmd.ast;
+
+public class ASTClassOrInterfaceType extends SimpleJavaNode {
+    public ASTClassOrInterfaceType(int id) {
+        super(id);
+    }
+
+    public ASTClassOrInterfaceType(JavaParser p, int id) {
+        super(p, id);
+    }
+
+
+    /**
+     * Accept the visitor. *
+     */
+    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
+        return visitor.visit(this, data);
+    }
+    
+    private Class type;
+    public void setType(Class type){
+        this.type = type;
+    }
+    
+    public Class getType(){
+        return type;
+    }
+
+}
Index: regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java
===================================================================
RCS file: /cvsroot/pmd/pmd/regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java,v
retrieving revision 1.5
diff -u -r1.5 LooseCouplingTest.java
--- regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java	22 Aug 2006 13:25:32 -0000	1.5
+++ regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java	25 Oct 2006 01:45:01 -0000
@@ -28,10 +28,12 @@
             new TestDescriptor(TEST8, "method param is HashMap", 1, rule),
             new TestDescriptor(TEST9, "Vector could be List", 1, rule),
             new TestDescriptor(TEST10, "ArrayList could be List", 1, rule),
+            new TestDescriptor(TEST11, "java.util.HashMap should be Map", 1, rule),
         });
     }
 
     private static final String TEST1 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet foo() {" + PMD.EOL +
             "  return new HashSet();" + PMD.EOL +
@@ -39,6 +41,8 @@
             "}";
 
     private static final String TEST2 =
+            "import java.util.Map;" + PMD.EOL +
+            "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " Map getFoo() {" + PMD.EOL +
             "  return new HashMap();" + PMD.EOL +
@@ -60,11 +64,13 @@
             "}";
 
     private static final String TEST5 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +
             "}";
 
     private static final String TEST6 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +
             " HashSet foo() { // NOT OK" + PMD.EOL +
@@ -73,26 +79,37 @@
             "}";
 
     private static final String TEST7 =
+        "import java.util.HashSet;" + PMD.EOL +
+        "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet();" + PMD.EOL +
             " HashMap fooMap = new HashMap();" + PMD.EOL +
             "}";
 
     private static final String TEST8 =
+        "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " void foo(HashMap bar) {}" + PMD.EOL +
             "}";
 
     private static final String TEST9 =
+        "import java.util.Vector;" + PMD.EOL +
             "import java.util.*;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " public void foo(Vector bar) {}" + PMD.EOL +
             "}";
 
     private static final String TEST10 =
+        "import java.util.ArrayList;" + PMD.EOL +
             "import java.util.*;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " public void foo(ArrayList bar) {}" + PMD.EOL +
             "}";
 
+
+    private static final String TEST11 =
+            "public class Foo {" + PMD.EOL +
+            " java.util.HashSet fooSet = new java.util.HashSet(); // NOT OK" + PMD.EOL +
+            "}";
+
 }
Index: src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java,v
retrieving revision 1.3
diff -u -r1.3 JavaTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java	10 Feb 2006 14:26:31 -0000	1.3
+++ src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java	25 Oct 2006 01:45:01 -0000
@@ -1,33 +1,44 @@
-package net.sourceforge.pmd.sourcetypehandlers;
-
-import net.sourceforge.pmd.ast.ASTCompilationUnit;
-import net.sourceforge.pmd.dfa.DataFlowFacade;
-import net.sourceforge.pmd.symboltable.SymbolFacade;
-
-/**
- * Implementation of VisitorsFactory for the Java AST. It uses anonymous classes
- * as adapters of the visitors to the VisitorStarter interface.
- *
- * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be
- */
-public abstract class JavaTypeHandler implements SourceTypeHandler {
-    private DataFlowFacade dataFlowFacade = new DataFlowFacade();
-    private SymbolFacade stb = new SymbolFacade();
-
-
-    public VisitorStarter getDataFlowFacade() {
-        return new VisitorStarter() {
-            public void start(Object rootNode) {
-                dataFlowFacade.initializeWith((ASTCompilationUnit) rootNode);
-            }
-        };
-    }
-
-    public VisitorStarter getSymbolFacade() {
-        return new VisitorStarter() {
-            public void start(Object rootNode) {
-                stb.initializeWith((ASTCompilationUnit) rootNode);
-            }
-        };
-    }
-}
+package net.sourceforge.pmd.sourcetypehandlers;
+
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.dfa.DataFlowFacade;
+import net.sourceforge.pmd.symboltable.SymbolFacade;
+import net.sourceforge.pmd.typeres.TypeResolutionFacade;
+
+/**
+ * Implementation of VisitorsFactory for the Java AST. It uses anonymous classes
+ * as adapters of the visitors to the VisitorStarter interface.
+ *
+ * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be
+ */
+public abstract class JavaTypeHandler implements SourceTypeHandler {
+    private DataFlowFacade dataFlowFacade = new DataFlowFacade();
+    private SymbolFacade stb = new SymbolFacade();
+    private TypeResolutionFacade tr = new TypeResolutionFacade();
+
+    public VisitorStarter getDataFlowFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                dataFlowFacade.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+
+    public VisitorStarter getSymbolFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                stb.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+    
+    public VisitorStarter getTypeResolutionFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                tr.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+    
+    
+}
Index: src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java,v
retrieving revision 1.4
diff -u -r1.4 SourceTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java	5 Oct 2006 00:25:59 -0000	1.4
+++ src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java	25 Oct 2006 01:45:01 -0000
@@ -30,4 +30,13 @@
      * @return VisitorStarter 
      */
     VisitorStarter getSymbolFacade();
+    
+    /**
+     * Get the getTypeResolutionFacade.
+     *
+     * @return VisitorStarter 
+     */
+    VisitorStarter getTypeResolutionFacade();
+    
+        
 }
Index: src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java,v
retrieving revision 1.5
diff -u -r1.5 JspTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java	23 Sep 2006 21:26:27 -0000	1.5
+++ src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java	25 Oct 2006 01:45:01 -0000
@@ -37,4 +37,8 @@
         return new JspSymbolFacade();
     }
 
+    public VisitorStarter getTypeResolutionFacade() {
+        return VisitorStarter.dummy;
+    }
+
 }
Index: src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
diff -N src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/ClassTypeResolver.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,114 @@
+/**
+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
+ */
+package net.sourceforge.pmd.typeres;
+
+import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;
+import net.sourceforge.pmd.ast.ASTClassOrInterfaceType;
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.ast.ASTImportDeclaration;
+import net.sourceforge.pmd.ast.ASTName;
+import net.sourceforge.pmd.ast.ASTPackageDeclaration;
+import net.sourceforge.pmd.ast.JavaParserVisitorAdapter;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class ClassTypeResolver extends JavaParserVisitorAdapter {
+
+	private static Map myPrimitiveTypes;
+
+	private static PMDASMClassLoader pmdClassLoader = new PMDASMClassLoader();
+
+	static {
+		Map thePrimitiveTypes = new HashMap();
+		thePrimitiveTypes.put("short", Short.TYPE);
+		thePrimitiveTypes.put("byte", Byte.TYPE);
+		thePrimitiveTypes.put("char", Character.TYPE);
+		thePrimitiveTypes.put("int", Integer.TYPE);
+		thePrimitiveTypes.put("long", Long.TYPE);
+		thePrimitiveTypes.put("float", Float.TYPE);
+		thePrimitiveTypes.put("double", Double.TYPE);
+		thePrimitiveTypes.put("boolean", Boolean.TYPE);
+		thePrimitiveTypes.put("void", Void.TYPE);
+		myPrimitiveTypes = Collections.unmodifiableMap(thePrimitiveTypes);
+	}
+
+	private Map importedClasses;
+
+	private String className;
+
+	public Object visit(ASTCompilationUnit node, Object data) {
+		try {
+			populateClassName(node);
+		} catch (ClassNotFoundException e) {
+			populateImports(node);
+		}
+		return super.visit(node, data);
+	}
+
+	/**
+	 * If the outer class wasn't found then we'll get in here
+	 * @param node
+	 */
+	private void populateImports(ASTCompilationUnit node) {
+		List theImportDeclarations = node.findChildrenOfType(ASTImportDeclaration.class);
+		importedClasses = new HashMap();
+
+		// go through the imports
+		for (Iterator anIterator = theImportDeclarations.iterator(); anIterator.hasNext();) {
+			ASTImportDeclaration anImportDeclaration = (ASTImportDeclaration) anIterator.next();
+			if (!anImportDeclaration.isImportOnDemand()) {
+				String strPackage = anImportDeclaration.getPackageName();
+				String strName = anImportDeclaration.getImportedName();
+				importedClasses.put(strName, strName);
+				importedClasses.put(strName.substring(strPackage.length() + 1), strName);
+			}
+		}
+
+		importedClasses.put("String", "java.lang.String");
+	}
+
+	private void populateClassName(ASTCompilationUnit node) throws ClassNotFoundException {
+		ASTClassOrInterfaceDeclaration decl = (ASTClassOrInterfaceDeclaration) node
+				.getFirstChildOfType(ASTClassOrInterfaceDeclaration.class);
+		if (decl != null) {
+			ASTPackageDeclaration pkgDecl = (ASTPackageDeclaration) node
+					.getFirstChildOfType(ASTPackageDeclaration.class);
+			className = pkgDecl == null ? decl.getImage() : ((ASTName) pkgDecl.jjtGetChild(0)).getImage() + "."
+					+ decl.getImage();
+			pmdClassLoader.loadClass(className);
+			importedClasses = pmdClassLoader.getImportedClasses(className);
+		}
+	}
+
+	// TODO - the map right now contains just class names. if we use
+	// a map of classname/class then we don't have to hit the class loader for
+	// every type - much faster
+	public Object visit(ASTClassOrInterfaceType node, Object data) {
+
+		String className = node.getImage();
+		String qualifiedName = className;
+		Class myType = (Class) myPrimitiveTypes.get(className);
+		if (myType == null && importedClasses != null) {
+			if (importedClasses.containsKey(className)) {
+				qualifiedName = (String) importedClasses.get(className);
+			} else if (importedClasses.containsValue(className)) {
+				qualifiedName = className;
+			}
+			if (qualifiedName != null) {
+				try {
+					myType = pmdClassLoader.loadClass(qualifiedName);
+				} catch (ClassNotFoundException e) {
+				}
+			}
+		}
+		if (myType != null) {
+			node.setType(myType);
+		}
+		return data;
+	}
+}
Index: src/net/sourceforge/pmd/typeres/visitors/PMDASMVisitor.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/visitors/PMDASMVisitor.java
diff -N src/net/sourceforge/pmd/typeres/visitors/PMDASMVisitor.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/visitors/PMDASMVisitor.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,384 @@
+/**
+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
+ */
+package net.sourceforge.pmd.typeres.visitors;
+
+import org.objectweb.asm.AnnotationVisitor;
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.signature.SignatureReader;
+import org.objectweb.asm.signature.SignatureVisitor;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class PMDASMVisitor implements ClassVisitor {
+
+	public Map packages = new HashMap();
+
+	private AnnotationVisitor annotationVisitor = new PMDAnnotationVisitor(this);
+
+	private FieldVisitor fieldVisitor = new PMDFieldVisitor(this);
+
+	private SignatureVisitor sigVisitor = new PMDSignatureVisitor(this);
+
+	private MethodVisitor methodVisitor = new PMDMethodVisitor(this);
+
+	public List innerClasses;
+
+	public Map getPackages() {
+		return packages;
+	}
+
+	public List getInnerClasses() {
+		return innerClasses;
+	}
+
+	private String parseClassName(String name) {
+		if (name == null) {
+			return null;
+		}
+
+		String className = name;
+		int n = name.lastIndexOf('/');
+		if (n > -1) {
+			className = name.substring(n + 1);
+		}
+		name = name.replace('/', '.');
+		packages.put(className, name);
+		n = className.indexOf('$');
+		if (n > -1) {
+			packages.put(className.substring(n + 1), name);
+		}
+
+		return name;
+	}
+
+	private void parseClassName(String[] names) {
+		if (names != null) {
+			for (int i = 0; i < names.length; i++) {
+				parseClassName(names[i]);
+			}
+		}
+	}
+
+	private void extractSignature(String sig) {
+		if (sig != null) {
+			new SignatureReader(sig).acceptType(sigVisitor);
+		}
+	}
+
+	/* Start ClassVisitor implementations */
+
+	public void visit(int version, int access, String name, String sig, String superName, String[] interfaces) {
+		parseClassName(name);
+		parseClassName(interfaces);
+		if (sig != null) {
+			extractSignature(sig);
+		}
+	}
+
+	public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
+		addType(Type.getType(desc));
+		return annotationVisitor;
+	}
+
+	public FieldVisitor visitField(int access, String name, String desc, String sig, Object value) {
+		if (sig != null) {
+			extractSignature(sig);
+		}
+
+		addType(Type.getType(desc));
+		if (value instanceof Type) {
+			addType((Type) value);
+		}
+		return fieldVisitor;
+	}
+
+	public MethodVisitor visitMethod(int access, String name, String desc, String sig, String[] exceptions) {
+		if (sig != null) {
+			extractSignature(sig);
+		}
+		addMethodDesc(desc);
+		parseClassName(exceptions);
+		return methodVisitor;
+	}
+
+	public void visitSource(String source, String debug) {
+	}
+
+	public void visitInnerClass(String name, String outerName, String innerName, int access) {
+		if (innerClasses == null) {
+			innerClasses = new ArrayList();
+		}
+		if (!innerClasses.contains(name.replace('/', '.'))) {
+			innerClasses.add(name.replace('/', '.'));
+		}
+		packages.put(innerName, name.replace('/', '.'));
+	}
+
+	public void visitOuterClass(String owner, String name, String desc) {
+	}
+
+	public void visitEnd() {
+	}
+
+	private void addMethodDesc(String desc) {
+		addTypes(desc);
+		addType(Type.getReturnType(desc));
+	}
+
+	private void addTypes(String desc) {
+		Type[] types = Type.getArgumentTypes(desc);
+		for (int i = 0; i < types.length; i++) {
+			addType(types[i]);
+		}
+	}
+
+	private void addType(Type t) {
+		switch (t.getSort()) {
+		case Type.ARRAY:
+			addType(t.getElementType());
+			break;
+		case Type.OBJECT:
+			parseClassName(t.getClassName().replace('.', '/'));
+			break;
+		}
+	}
+
+	public void visitAttribute(Attribute attr) {
+	}
+
+	/*
+	 * Start visitors
+	 */
+
+	private class PMDFieldVisitor implements FieldVisitor {
+
+		private PMDASMVisitor parent;
+
+		public PMDFieldVisitor(PMDASMVisitor visitor) {
+			parent = visitor;
+		}
+
+		public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
+			parent.addType(Type.getType(desc));
+			return parent.annotationVisitor;
+		}
+
+		public void visitAttribute(Attribute attr) {
+		}
+
+		public void visitEnd() {
+		}
+	}
+
+	private class PMDAnnotationVisitor implements AnnotationVisitor {
+		private PMDASMVisitor parent;
+
+		public PMDAnnotationVisitor(PMDASMVisitor visitor) {
+			parent = visitor;
+		}
+
+		public AnnotationVisitor visitAnnotation(String name, String desc) {
+			parent.addType(Type.getType(desc));
+			return this;
+		}
+
+		public void visitEnum(String name, String desc, String value) {
+			parent.addType(Type.getType(desc));
+		}
+
+		public AnnotationVisitor visitArray(String name) {
+			return this;
+		}
+
+		public void visitEnd() {
+		}
+
+		public void visit(String name, Object value) {
+			if (value instanceof Type) {
+				parent.addType((Type) value);
+			}
+		}
+	}
+
+	private class PMDSignatureVisitor implements SignatureVisitor {
+		private PMDASMVisitor parent;
+
+		public PMDSignatureVisitor(PMDASMVisitor visitor) {
+			this.parent = visitor;
+		}
+
+		public void visitFormalTypeParameter(String name) {
+		}
+
+		public SignatureVisitor visitClassBound() {
+			return this;
+		}
+
+		public SignatureVisitor visitInterfaceBound() {
+			return this;
+		}
+
+		public SignatureVisitor visitSuperclass() {
+			return this;
+		}
+
+		public SignatureVisitor visitInterface() {
+			return this;
+		}
+
+		public SignatureVisitor visitParameterType() {
+			return this;
+		}
+
+		public SignatureVisitor visitReturnType() {
+			return this;
+		}
+
+		public SignatureVisitor visitExceptionType() {
+			return this;
+		}
+
+		public void visitBaseType(char descriptor) {
+		}
+
+		public void visitTypeVariable(String name) {
+		}
+
+		public SignatureVisitor visitArrayType() {
+			return this;
+		}
+
+		public void visitClassType(String name) {
+			parent.parseClassName(name);
+		}
+
+		public void visitInnerClassType(String name) {
+			parent.parseClassName(name);
+		}
+
+		public void visitTypeArgument() {
+		}
+
+		public SignatureVisitor visitTypeArgument(char wildcard) {
+			return this;
+		}
+
+		public void visitEnd() {
+		}
+	}
+
+	private class PMDMethodVisitor implements MethodVisitor {
+		private PMDASMVisitor parent;
+
+		public PMDMethodVisitor(PMDASMVisitor visitor) {
+			parent = visitor;
+		}
+
+		public AnnotationVisitor visitParameterAnnotation(int parameter, String desc, boolean visible) {
+			parent.addType(Type.getType(desc));
+			return parent.annotationVisitor;
+		}
+
+		public AnnotationVisitor visitAnnotation(String name, String desc) {
+			parent.addType(Type.getType(desc));
+			return parent.annotationVisitor;
+		}
+
+		public void visitTypeInsn(int opcode, String desc) {
+			if (desc.charAt(0) == '[') {
+				parent.addType(Type.getType(desc));
+			} else {
+				parent.parseClassName(desc);
+			}
+		}
+
+		public void visitFieldInsn(int opcode, String owner, String name, String desc) {
+			parent.parseClassName(owner);
+			parent.addType(Type.getType(desc));
+		}
+
+		public void visitMethodInsn(int opcode, String owner, String name, String desc) {
+			parent.parseClassName(owner);
+			parent.addMethodDesc(desc);
+		}
+
+		public void visitLdcInsn(Object cst) {
+			if (cst instanceof Type) {
+				parent.addType((Type) cst);
+			}
+		}
+
+		public void visitMultiANewArrayInsn(String desc, int dims) {
+			parent.addType(Type.getType(desc));
+		}
+
+		public void visitLocalVariable(String name, String desc, String sig, Label start, Label end, int index) {
+			parent.extractSignature(sig);
+		}
+
+		public void visitCode() {
+		}
+
+		public void visitFrame(int type, int nLocal, Object[] local, int nStack, Object[] stack) {
+		}
+
+		public void visitInsn(int opcode) {
+		}
+
+		public void visitIntInsn(int opcode, int operand) {
+		}
+
+		public void visitVarInsn(int opcode, int var) {
+		}
+
+		public void visitJumpInsn(int opcode, Label label) {
+		}
+
+		public void visitLabel(Label label) {
+		}
+
+		public void visitIincInsn(int var, int increment) {
+		}
+
+		public void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels) {
+		}
+
+		public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
+		}
+
+		public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
+			parent.parseClassName(type);
+		}
+
+		public void visitLineNumber(int line, Label start) {
+		}
+
+		public void visitMaxs(int maxStack, int maxLocals) {
+		}
+
+		public AnnotationVisitor visitAnnotationDefault() {
+			return parent.annotationVisitor;
+		}
+
+		public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
+			parent.addType(Type.getType(desc));
+			return annotationVisitor;
+		}
+
+		public void visitEnd() {
+		}
+
+		public void visitAttribute(Attribute attr) {
+		}
+
+	}
+}
Index: src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
diff -N src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,19 @@
+/**
+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
+ */
+package net.sourceforge.pmd.typeres;
+
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.ast.JavaParserVisitorAdapter;
+
+/**
+ * @author Allan Caplan
+ */
+public class TypeResolutionFacade extends JavaParserVisitorAdapter {
+
+    public void initializeWith(ASTCompilationUnit node) {
+        ClassTypeResolver ctr = new ClassTypeResolver();
+        node.jjtAccept(ctr, null);
+    }
+
+}
Index: src/net/sourceforge/pmd/typeres/PMDASMClassLoader.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/PMDASMClassLoader.java
diff -N src/net/sourceforge/pmd/typeres/PMDASMClassLoader.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/PMDASMClassLoader.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,76 @@
+/**
+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
+ */
+package net.sourceforge.pmd.typeres;
+
+import net.sourceforge.pmd.typeres.visitors.PMDASMVisitor;
+
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class PMDASMClassLoader extends ClassLoader {
+
+	public PMDASMClassLoader() {
+	}
+
+	public synchronized Class loadClass(String name) throws ClassNotFoundException {
+		return defineClass(name);
+	}
+
+	private Map importedClasses = new HashMap();
+
+	private Set dontBother = new HashSet();
+
+	public Map getImportedClasses(String className) {
+		Map ret = (Map) importedClasses.get(className);
+		return ret == null ? new HashMap() : ret;
+	}
+
+	private Class defineClass(String name) throws ClassNotFoundException {
+
+		if (dontBother.contains(name)) {
+			throw new ClassNotFoundException(name);
+		}
+		try {
+			if (name.startsWith("java.")) {
+				return Class.forName(name);
+			}
+			if (importedClasses.containsKey(name)) {
+				if (super.findLoadedClass(name) != null) {
+					return super.findLoadedClass(name);
+				}
+			}
+			ClassReader reader = new ClassReader(getResourceAsStream(name.replace('.', '/') + ".class"));
+			PMDASMVisitor asmVisitor = new PMDASMVisitor();
+			reader.accept(asmVisitor, 0);
+
+			List inner = asmVisitor.getInnerClasses();
+			if (inner != null && !inner.isEmpty()) {
+				for (int ix = 0; ix < inner.size(); ix++) {
+					String str = (String) inner.get(ix);
+					ClassReader innerReader = new ClassReader(getResourceAsStream(str.replace('.', '/') + ".class"));
+					innerReader.accept(asmVisitor, 0);
+				}
+			}
+			importedClasses.put(name, asmVisitor.packages);
+			ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);
+			reader.accept(writer, 0);
+
+			byte[] byteCode = writer.toByteArray();
+			return defineClass(name, byteCode, 0, byteCode.length);
+		} catch (ClassNotFoundException e) {
+			dontBother.add(name);
+			throw e;
+		} catch (IOException e) {
+			dontBother.add(name);
+			throw new ClassNotFoundException(name, e);
+		}
+	}
+}
