Index: src/net/sourceforge/pmd/rules/design/LooseCoupling.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/rules/design/LooseCoupling.java,v
retrieving revision 1.9
diff -u -r1.9 LooseCoupling.java
--- src/net/sourceforge/pmd/rules/design/LooseCoupling.java	10 Oct 2006 05:36:05 -0000	1.9
+++ src/net/sourceforge/pmd/rules/design/LooseCoupling.java	18 Oct 2006 00:19:15 -0000
@@ -1,7 +1,7 @@
 /**
  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html
  */
-package net.sourceforge.pmd.rules.design;
+/*package net.sourceforge.pmd.rules.design;
 
 import java.util.Set;
 
@@ -35,3 +35,49 @@
         return data;
     }
 }
+
+
+*/
+
+package net.sourceforge.pmd.rules.design;
+
+import net.sourceforge.pmd.AbstractRule;
+import net.sourceforge.pmd.ast.ASTClassOrInterfaceType;
+import net.sourceforge.pmd.ast.ASTFieldDeclaration;
+import net.sourceforge.pmd.ast.ASTFormalParameter;
+import net.sourceforge.pmd.ast.ASTResultType;
+import net.sourceforge.pmd.ast.Node;
+import net.sourceforge.pmd.util.CollectionUtil;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.Vector;
+
+public class LooseCoupling extends AbstractRule {
+
+    private static final Set implClasses = CollectionUtil.asSet(new Object[] { ArrayList.class, HashSet.class,
+            HashMap.class, LinkedHashMap.class, LinkedHashSet.class, TreeSet.class, TreeMap.class, Vector.class });
+
+    public LooseCoupling() {
+        super();
+    }
+
+    public Object visit(ASTClassOrInterfaceType node, Object data) {
+        Class clazz = node.getType();
+        if(clazz == null){
+            System.err.println(node.getImage() + " not found in classpath??");
+        }
+        Node parent = node.jjtGetParent().jjtGetParent().jjtGetParent();
+        if (implClasses.contains(clazz)
+                && (parent instanceof ASTFieldDeclaration || parent instanceof ASTFormalParameter || parent instanceof ASTResultType)) {
+            addViolation(data, node, node.getImage());
+        }
+        return data;
+    }
+}
Index: src/net/sourceforge/pmd/PMD.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/PMD.java,v
retrieving revision 1.148
diff -u -r1.148 PMD.java
--- src/net/sourceforge/pmd/PMD.java	16 Oct 2006 19:10:42 -0000	1.148
+++ src/net/sourceforge/pmd/PMD.java	18 Oct 2006 00:19:15 -0000
@@ -79,8 +79,13 @@
 
             Language language = SourceTypeToRuleLanguageMapper.getMappedLanguage(sourceType);
 
-            if (ruleSets.usesDFA(language)) {
+/*            if (ruleSets.usesDFA(language)) {
                 sourceTypeHandler.getDataFlowFacade().start(rootNode);
+            }*/
+
+            if (true) {
+//          if (ruleSets.usesTypeRes(language)) {
+                sourceTypeHandler.getTypeResolutionFacade().start(rootNode);
             }
 
             List acus = new ArrayList();
@@ -209,6 +214,8 @@
     }
 
     public static void main(String[] args) {
+        
+        long start = System.currentTimeMillis();
         CommandLineOptions opts = new CommandLineOptions(args);
 
         SourceFileSelector fileSelector = new SourceFileSelector();
@@ -275,6 +282,11 @@
                 e.printStackTrace();
             }
         }
+        long end = System.currentTimeMillis();
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
+        System.err.println("\nTime: " + (end-start));
     }
 
     /**
Index: src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java,v
retrieving revision 1.5
diff -u -r1.5 ASTClassOrInterfaceType.java
--- src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java	10 Feb 2006 14:26:28 -0000	1.5
+++ src/net/sourceforge/pmd/ast/ASTClassOrInterfaceType.java	18 Oct 2006 00:19:15 -0000
@@ -1,22 +1,31 @@
-/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceType.java */
-
-package net.sourceforge.pmd.ast;
-
-public class ASTClassOrInterfaceType extends SimpleJavaNode {
-    public ASTClassOrInterfaceType(int id) {
-        super(id);
-    }
-
-    public ASTClassOrInterfaceType(JavaParser p, int id) {
-        super(p, id);
-    }
-
-
-    /**
-     * Accept the visitor. *
-     */
-    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
-        return visitor.visit(this, data);
-    }
-
-}
+/* Generated By:JJTree: Do not edit this line. ASTClassOrInterfaceType.java */
+
+package net.sourceforge.pmd.ast;
+
+public class ASTClassOrInterfaceType extends SimpleJavaNode {
+    public ASTClassOrInterfaceType(int id) {
+        super(id);
+    }
+
+    public ASTClassOrInterfaceType(JavaParser p, int id) {
+        super(p, id);
+    }
+
+
+    /**
+     * Accept the visitor. *
+     */
+    public Object jjtAccept(JavaParserVisitor visitor, Object data) {
+        return visitor.visit(this, data);
+    }
+    
+    private Class type;
+    public void setType(Class type){
+        this.type = type;
+    }
+    
+    public Class getType(){
+        return type;
+    }
+
+}
Index: regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java
===================================================================
RCS file: /cvsroot/pmd/pmd/regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java,v
retrieving revision 1.5
diff -u -r1.5 LooseCouplingTest.java
--- regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java	22 Aug 2006 13:25:32 -0000	1.5
+++ regress/test/net/sourceforge/pmd/rules/design/LooseCouplingTest.java	18 Oct 2006 00:19:15 -0000
@@ -28,10 +28,12 @@
             new TestDescriptor(TEST8, "method param is HashMap", 1, rule),
             new TestDescriptor(TEST9, "Vector could be List", 1, rule),
             new TestDescriptor(TEST10, "ArrayList could be List", 1, rule),
+            new TestDescriptor(TEST11, "java.util.HashMap should be Map", 1, rule),
         });
     }
 
     private static final String TEST1 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet foo() {" + PMD.EOL +
             "  return new HashSet();" + PMD.EOL +
@@ -39,6 +41,8 @@
             "}";
 
     private static final String TEST2 =
+            "import java.util.Map;" + PMD.EOL +
+            "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " Map getFoo() {" + PMD.EOL +
             "  return new HashMap();" + PMD.EOL +
@@ -60,11 +64,13 @@
             "}";
 
     private static final String TEST5 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +
             "}";
 
     private static final String TEST6 =
+            "import java.util.HashSet;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +
             " HashSet foo() { // NOT OK" + PMD.EOL +
@@ -73,26 +79,37 @@
             "}";
 
     private static final String TEST7 =
+        "import java.util.HashSet;" + PMD.EOL +
+        "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " HashSet fooSet = new HashSet();" + PMD.EOL +
             " HashMap fooMap = new HashMap();" + PMD.EOL +
             "}";
 
     private static final String TEST8 =
+        "import java.util.HashMap;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " void foo(HashMap bar) {}" + PMD.EOL +
             "}";
 
     private static final String TEST9 =
+        "import java.util.Vector;" + PMD.EOL +
             "import java.util.*;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " public void foo(Vector bar) {}" + PMD.EOL +
             "}";
 
     private static final String TEST10 =
+        "import java.util.ArrayList;" + PMD.EOL +
             "import java.util.*;" + PMD.EOL +
             "public class Foo {" + PMD.EOL +
             " public void foo(ArrayList bar) {}" + PMD.EOL +
             "}";
 
+
+    private static final String TEST11 =
+            "public class Foo {" + PMD.EOL +
+            " java.util.HashSet fooSet = new java.util.HashSet(); // NOT OK" + PMD.EOL +
+            "}";
+
 }
Index: src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java,v
retrieving revision 1.4
diff -u -r1.4 SourceTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java	5 Oct 2006 00:25:59 -0000	1.4
+++ src/net/sourceforge/pmd/sourcetypehandlers/SourceTypeHandler.java	18 Oct 2006 00:19:15 -0000
@@ -30,4 +30,13 @@
      * @return VisitorStarter 
      */
     VisitorStarter getSymbolFacade();
+    
+    /**
+     * Get the getTypeResolutionFacade.
+     *
+     * @return VisitorStarter 
+     */
+    VisitorStarter getTypeResolutionFacade();
+    
+        
 }
Index: src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java,v
retrieving revision 1.3
diff -u -r1.3 JavaTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java	10 Feb 2006 14:26:31 -0000	1.3
+++ src/net/sourceforge/pmd/sourcetypehandlers/JavaTypeHandler.java	18 Oct 2006 00:19:15 -0000
@@ -1,33 +1,45 @@
-package net.sourceforge.pmd.sourcetypehandlers;
-
-import net.sourceforge.pmd.ast.ASTCompilationUnit;
-import net.sourceforge.pmd.dfa.DataFlowFacade;
-import net.sourceforge.pmd.symboltable.SymbolFacade;
-
-/**
- * Implementation of VisitorsFactory for the Java AST. It uses anonymous classes
- * as adapters of the visitors to the VisitorStarter interface.
- *
- * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be
- */
-public abstract class JavaTypeHandler implements SourceTypeHandler {
-    private DataFlowFacade dataFlowFacade = new DataFlowFacade();
-    private SymbolFacade stb = new SymbolFacade();
-
-
-    public VisitorStarter getDataFlowFacade() {
-        return new VisitorStarter() {
-            public void start(Object rootNode) {
-                dataFlowFacade.initializeWith((ASTCompilationUnit) rootNode);
-            }
-        };
-    }
-
-    public VisitorStarter getSymbolFacade() {
-        return new VisitorStarter() {
-            public void start(Object rootNode) {
-                stb.initializeWith((ASTCompilationUnit) rootNode);
-            }
-        };
-    }
-}
+package net.sourceforge.pmd.sourcetypehandlers;
+
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.dfa.DataFlowFacade;
+import net.sourceforge.pmd.symboltable.SymbolFacade;
+import net.sourceforge.pmd.typeres.TypeResolutionFacade;
+
+/**
+ * Implementation of VisitorsFactory for the Java AST. It uses anonymous classes
+ * as adapters of the visitors to the VisitorStarter interface.
+ *
+ * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be
+ */
+public abstract class JavaTypeHandler implements SourceTypeHandler {
+    private DataFlowFacade dataFlowFacade = new DataFlowFacade();
+    private SymbolFacade stb = new SymbolFacade();
+    private TypeResolutionFacade tr = new TypeResolutionFacade();
+
+
+    public VisitorStarter getDataFlowFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                dataFlowFacade.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+
+    public VisitorStarter getSymbolFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                stb.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+    
+    public VisitorStarter getTypeResolutionFacade() {
+        return new VisitorStarter() {
+            public void start(Object rootNode) {
+                tr.initializeWith((ASTCompilationUnit) rootNode);
+            }
+        };
+    }
+    
+    
+}
Index: src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java
===================================================================
RCS file: /cvsroot/pmd/pmd/src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java,v
retrieving revision 1.5
diff -u -r1.5 JspTypeHandler.java
--- src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java	23 Sep 2006 21:26:27 -0000	1.5
+++ src/net/sourceforge/pmd/sourcetypehandlers/JspTypeHandler.java	18 Oct 2006 00:19:15 -0000
@@ -37,4 +37,8 @@
         return new JspSymbolFacade();
     }
 
+    public VisitorStarter getTypeResolutionFacade() {
+        return VisitorStarter.dummy;
+    }
+
 }
Index: src/net/sourceforge/pmd/util/PMDClassLoader.java
===================================================================
RCS file: src/net/sourceforge/pmd/util/PMDClassLoader.java
diff -N src/net/sourceforge/pmd/util/PMDClassLoader.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/util/PMDClassLoader.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,231 @@
+package net.sourceforge.pmd.util;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.TreeMap;
+import java.util.jar.JarFile;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+public class PMDClassLoader extends ClassLoader {
+
+    private Object objMutex = new Object();
+
+    private Map cachedClasses = new HashMap();
+
+    private Map classToJarMap = new HashMap();
+
+    public PMDClassLoader() {
+        super();
+        preload(System.getProperty("sun.boot.class.path", "."));
+        preload(System.getProperty("java.class.path", "."));
+    }
+
+    private void preload(String cp) {
+        StringTokenizer tok = new StringTokenizer(cp, File.pathSeparator);
+        while (tok.hasMoreTokens()) {
+            String path = tok.nextToken();
+            Descriptor descriptor = DescriptorFactory.getDescriptor(path);
+            try {
+                List lst = descriptor.getEntries();
+                classToJarMap.put(path, lst);
+            } catch (IOException e) {
+                // e.printStackTrace();
+            }
+        }
+    }
+
+    public Class findClass(String name) throws ClassNotFoundException {
+        if (cachedClasses.containsKey(name)) {
+            return (Class) cachedClasses.get(name);
+        }
+        synchronized (objMutex) {
+            try {
+                Class clazz = null;
+                if (name.startsWith("java.")) {
+                    clazz = Class.forName(name);
+                    cachedClasses.put(name, clazz);
+                    // System.err.println("Loaded: " + clazz);
+                    return clazz;
+                }
+
+                clazz = super.findLoadedClass(name);
+                if (clazz != null) {
+                    cachedClasses.put(name, clazz);
+                    // System.err.println("Loaded: " + clazz);
+                    return clazz;
+                }
+                byte[] b = loadClassData(name);
+                if (b == null) {
+                    throw new ClassNotFoundException(name);
+                }
+                clazz = defineClass(name, b, 0, b.length);
+                cachedClasses.put(name, clazz);
+                // System.err.println("Loaded: " + clazz);
+                return clazz;
+            } catch (ClassFormatError e) {
+                throw new ClassNotFoundException(name);
+            } catch (ClassNotFoundException e) {
+                throw new ClassNotFoundException(name);
+            }
+        }
+    }
+
+    private byte[] loadClassData(String name) {
+
+        byte[] classData = findClass(name, System.getProperty("sun.boot.class.path", "."));
+        if (classData == null) {
+            classData = findClass(name, System.getProperty("java.class.path", "."));
+        }
+        return classData;
+    }
+
+    private byte[] findClass(String name, String cp) {
+        StringTokenizer tok = new StringTokenizer(cp, File.pathSeparator);
+        while (tok.hasMoreTokens()) {
+            String path = tok.nextToken();
+            List cachedClasses = (List) classToJarMap.get(path);
+            Descriptor descriptor = DescriptorFactory.getDescriptor(path);
+            if (cachedClasses == null) {
+                cachedClasses = new ArrayList();
+                classToJarMap.put(path, cachedClasses);
+            }
+            try {
+                if (cachedClasses.contains(name)) {
+                    byte[] bytes = descriptor.getBytes(name);
+                    if (bytes != null) {
+                        return bytes;
+                    }
+                } else if (descriptor instanceof PathDescriptor) {
+                    byte[] bytes = descriptor.getBytes(name);
+                    if (bytes != null) {
+                        cachedClasses.add(name);
+                        return bytes;
+                    }
+                }
+            } catch (IOException e) {
+                // This is OK - we didn't find the class, keep going
+            }
+        }
+        return null;
+    }
+
+    public static interface Descriptor {
+        public byte[] getBytes(String name) throws IOException;
+
+        public List getEntries() throws IOException;
+    }
+
+    public static class DescriptorFactory {
+        public static Descriptor getDescriptor(String path) {
+            if (path.endsWith(".jar")) {
+                return new JarDescriptor(path);
+            } else if (path.endsWith(".zip")) {
+                return new ZipDescriptor(path);
+            } else {
+                return new PathDescriptor(path);
+            }
+        }
+    }
+
+    public static class ZipDescriptor implements Descriptor {
+        private String fileName;
+
+        private ZipDescriptor() {
+        }
+
+        public ZipDescriptor(String fileName) {
+            this.fileName = fileName;
+        }
+
+        public byte[] getBytes(String name) throws IOException {
+            ZipFile zipFile = new ZipFile(fileName);
+            ZipEntry zipEntry = zipFile.getEntry(name.replace('.', '/') + ".class");
+            if (zipEntry != null) {
+                return readBytes(zipFile.getInputStream(zipEntry));
+            }
+            return null;
+        }
+
+        public List getEntries() throws IOException {
+            ZipFile zipFile = new ZipFile(fileName);
+            List lstEntries = new ArrayList();
+            for (Enumeration entries = zipFile.entries(); entries.hasMoreElements();) {
+                ZipEntry entry = (ZipEntry) entries.nextElement();
+                // System.err.println(entry.getName());
+                lstEntries.add(entry.getName());
+            }
+            return lstEntries;
+        }
+    }
+
+    public static class JarDescriptor implements Descriptor {
+        private String fileName;
+
+        public JarDescriptor(String fileName) {
+            this.fileName = fileName;
+        }
+
+        public byte[] getBytes(String name) throws IOException {
+            JarFile jarFile = new JarFile(fileName);
+            ZipEntry zipEntry = jarFile.getEntry(name.replace('.', '/') + ".class");
+            if (zipEntry != null) {
+                return readBytes(jarFile.getInputStream(zipEntry));
+            }
+            return null;
+        }
+
+        public List getEntries() throws IOException {
+            JarFile jarFile = new JarFile(fileName);
+            List lstEntries = new ArrayList();
+            for (Enumeration entries = jarFile.entries(); entries.hasMoreElements();) {
+                ZipEntry entry = (ZipEntry) entries.nextElement();
+                // System.err.println(entry.getName());
+                lstEntries.add(entry.getName());
+            }
+            return lstEntries;
+        }
+    }
+
+    public static class PathDescriptor implements Descriptor {
+        private String fileName;
+
+        public PathDescriptor(String fileName) {
+            this.fileName = fileName;
+        }
+
+        public byte[] getBytes(String name) throws IOException {
+            return readBytes(new FileInputStream(fileName + '\\' + name.replace('.', '\\') + ".class"));
+        }
+
+        public List getEntries() throws IOException {
+            List lstEntries = new ArrayList();
+            return lstEntries;
+        }
+
+    }
+
+    public static byte[] readBytes(InputStream in) throws IOException {
+        byte[] classBytes = new byte[in.available()];
+        in.read(classBytes);
+        return classBytes;
+    }
+
+    public static void main(String[] args) throws ClassNotFoundException {
+        PMDClassLoader l = new PMDClassLoader();
+        Class c = l.findClass("net.sourceforge.pmd.PMD");
+        System.err.println(c);
+        Class c2 = l.findClass("java.lang.String");
+        System.err.println(c2);
+    }
+
+}
Index: src/net/sourceforge/pmd/util/StaticOne.java
===================================================================
RCS file: src/net/sourceforge/pmd/util/StaticOne.java
diff -N src/net/sourceforge/pmd/util/StaticOne.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/util/StaticOne.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,7 @@
+package net.sourceforge.pmd.util;
+
+public class StaticOne {
+    static {
+        System.err.println("This should print out");
+    }
+}
Index: src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
diff -N src/net/sourceforge/pmd/typeres/ClassTypeResolver.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/ClassTypeResolver.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,198 @@
+package net.sourceforge.pmd.typeres;
+
+import net.sourceforge.pmd.ast.ASTClassOrInterfaceType;
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.ast.ASTImportDeclaration;
+import net.sourceforge.pmd.ast.JavaParserVisitorAdapter;
+import net.sourceforge.pmd.util.PMDClassLoader;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class ClassTypeResolver extends JavaParserVisitorAdapter {
+
+    private static final String myJavaLangPackage = "java.lang";
+
+    private static Map myPrimitiveTypes = null;
+
+    private static PMDClassLoader pmdClassLoader = new PMDClassLoader();
+
+    static {
+
+        Map thePrimitiveTypes = new HashMap();
+
+        thePrimitiveTypes.put("short", Short.TYPE);
+        thePrimitiveTypes.put("byte", Byte.TYPE);
+        thePrimitiveTypes.put("char", Character.TYPE);
+        thePrimitiveTypes.put("int", Integer.TYPE);
+        thePrimitiveTypes.put("long", Long.TYPE);
+        thePrimitiveTypes.put("float", Float.TYPE);
+        thePrimitiveTypes.put("double", Double.TYPE);
+        thePrimitiveTypes.put("boolean", Boolean.TYPE);
+        thePrimitiveTypes.put("void", Void.TYPE);
+
+        myPrimitiveTypes = Collections.unmodifiableMap(thePrimitiveTypes);
+
+    }
+
+    List theImportDeclarations;
+
+    Set thePackages = new HashSet();
+
+    Map packageNameMap = new HashMap();
+
+    public Object visit(ASTCompilationUnit node, Object data) {
+        // Find the list of imports ...
+        theImportDeclarations = node.findChildrenOfType(ASTImportDeclaration.class);
+
+        // Build the list of packages to check. We do this separtely to account
+        // for default imports ...
+        thePackages = new HashSet();
+        packageNameMap = new HashMap();
+
+        for (Iterator anIterator = theImportDeclarations.iterator(); anIterator.hasNext();) {
+            ASTImportDeclaration anImportDeclaration = (ASTImportDeclaration) anIterator.next();
+
+            String strPackage = anImportDeclaration.getPackageName();
+            String strName = anImportDeclaration.getImportedName();
+            if (thePackages.contains(strPackage) == false && strPackage != null) {
+                if (anImportDeclaration.isImportOnDemand()) {
+                    thePackages.add(strPackage);
+                } else {
+                    packageNameMap.put(strName.substring(strPackage.length() + 1), strName);
+                }
+            }
+        }
+        // Add java.lang last
+        thePackages.add(myJavaLangPackage);
+        packageNameMap.put("String", "java.lang.String");
+        packageNameMap.put("StringBuffer", "java.lang.StringBuffer");
+        return super.visit(node, data);
+    }
+
+    public Object visit(ASTClassOrInterfaceType node, Object data) {
+
+        Class type = getType(node);
+        if (type != null) {
+            node.setType(type);
+        }
+        return data;
+    }
+
+    /**
+     * 
+     * Accessor for the java.lang.Class represented by this type node. It works
+     * on the presumption that a type symbol (e.g. <codeMap</code) resolves to
+     * one and only one class within the context of a class.
+     * 
+     * This method does not handle type symbols that occur in multiple packages
+     * or type declared using fully qualified names. Since the PMD parse tree
+     * does not capture a fully qualified type name of a local variable,
+     * parameter, return type, or field declaration, it is impossible to resolve
+     * types from two packages (e.g. a class that uses both <codejava.util.Date</code
+     * and <codejava.sql.Date</code). In such a scenario, this method will
+     * resolve the class that appears first in the list of imports. In the
+     * scenario where the class is not in an imported package, this method will
+     * return <codejava.lang.Void.Type</code.
+     * 
+     * For primitive types, this method will return the TYPE constant it
+     * associated class in java.lang (e.g. <codeboolean</code will be returned
+     * as <codejava.lang.Boolean.TYPE</code).
+     * 
+     * @return The java.lang.Class instance of the type represent by this node
+     * 
+     */
+    public Class getType(ASTClassOrInterfaceType type) {
+
+        String strType = type.getImage();
+        Class myType = (Class) myPrimitiveTypes.get(strType);
+
+        // The type wasn't a primitive, so we need to go mucking through the
+        // imports to find it ...
+        if (myType == null) {
+
+            // Cycle through the list of imports, attempting to load a class
+            // of the name a package name + "." + the class name. Since many
+            // developers declare imports on a per class basis, we use a set
+            // to ensure we only attempt to load a class in a package once
+            if (packageNameMap.containsKey(strType)) {
+                try {
+                    // System.err.println("Fastpath to: " + strType);
+                    myType = pmdClassLoader.findClass((String) packageNameMap.get(strType));
+                } catch (ClassNotFoundException e) {
+                    // ignore: The exception indicates that the class was
+                    // not found in the current package, so move onto the
+                    // next package ...
+                } catch (IllegalAccessError e) {
+
+                } catch (NoClassDefFoundError e) {
+                    // investigate this one!
+                }
+            } else {
+                for (Iterator anIterator = thePackages.iterator(); anIterator.hasNext();) {
+                    String aPackage = (String) anIterator.next();
+                    try {
+                        // System.err.println("Looking for " + strType + " in "
+                        // + aPackage);
+                        myType = pmdClassLoader.findClass(aPackage + "." + strType);
+                        // Now that we've found it, let's add it to the class'
+                        // cache to make lookup faster for this class
+                        packageNameMap.put(strType, aPackage + "." + strType);
+                        break;
+                    } catch (ClassNotFoundException e) {
+                        // ignore: The exception indicates that the class was
+                        // not found in the current package, so move onto the
+                        // next package ...
+                    } catch (IllegalAccessError e) {
+
+                    } catch (NoClassDefFoundError e) {
+                        // investigate this one!
+                    }
+                }
+            }
+        }
+
+        // We didn't find the class, so we will assume the type is void ...
+        if (myType == null) {
+            try {
+                // is it base package
+                myType = pmdClassLoader.findClass(strType);
+                // Now that we've found it, let's add it to the class'
+                // cache to make lookup faster for this class
+                packageNameMap.put(strType, strType);
+            } catch (ClassNotFoundException e) {
+                // ignore: The exception indicates that the class was
+                // not found in the current package, so move onto the
+                // next package ...
+            } catch (IllegalAccessError e) {
+
+            } catch (NoClassDefFoundError e) {
+                // investigate this one!
+            }
+            if (myType == null) {
+                myType = NullSymbolType.class;
+            }
+        }
+
+        return myType;
+    }
+
+    public static final class NullSymbolType {
+
+        public static boolean isTypeNull(Class aClass) {
+
+            return NullSymbolType.class.equals(aClass);
+        }
+
+        private NullSymbolType() {
+            super();
+        }
+
+    }
+
+}
Index: src/net/sourceforge/pmd/util/ClassLoaderTest.java
===================================================================
RCS file: src/net/sourceforge/pmd/util/ClassLoaderTest.java
diff -N src/net/sourceforge/pmd/util/ClassLoaderTest.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/util/ClassLoaderTest.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,11 @@
+package net.sourceforge.pmd.util;
+
+/*
+ * This class shows how the PMDClassLoader does *NOT* fire the static initializers
+ */
+public class ClassLoaderTest {
+    public static void main(String[] args) throws ClassNotFoundException {
+        System.err.println(Class.forName("net.sourceforge.pmd.util.StaticOne"));
+        System.err.println(new PMDClassLoader().findClass("net.sourceforge.pmd.util.StaticTwo"));
+    }
+}
Index: src/net/sourceforge/pmd/util/StaticTwo.java
===================================================================
RCS file: src/net/sourceforge/pmd/util/StaticTwo.java
diff -N src/net/sourceforge/pmd/util/StaticTwo.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/util/StaticTwo.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,9 @@
+package net.sourceforge.pmd.util;
+
+public class StaticTwo {
+
+    static {
+        System.err.println("This should not print out");
+    }
+    
+}
Index: src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
diff -N src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/TypeResolutionFacade.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,19 @@
+/*
+ * Created on 10.07.2004
+ */
+package net.sourceforge.pmd.typeres;
+
+import net.sourceforge.pmd.ast.ASTCompilationUnit;
+import net.sourceforge.pmd.ast.JavaParserVisitorAdapter;
+
+/**
+ * @author Allan Caplan
+ */
+public class TypeResolutionFacade extends JavaParserVisitorAdapter {
+
+    public void initializeWith(ASTCompilationUnit node) {
+        ClassTypeResolver ctr = new ClassTypeResolver();
+        node.jjtAccept(ctr, null);
+    }
+
+}
Index: src/net/sourceforge/pmd/typeres/TypeResolver.java
===================================================================
RCS file: src/net/sourceforge/pmd/typeres/TypeResolver.java
diff -N src/net/sourceforge/pmd/typeres/TypeResolver.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/net/sourceforge/pmd/typeres/TypeResolver.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,6 @@
+package net.sourceforge.pmd.typeres;
+
+
+public class TypeResolver {
+
+}
